<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Cribbage</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.164/examples/js/loaders/FBXLoader.js"></script>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 1, 3);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const floorGeo = new THREE.BoxGeometry(20, 1, 20);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.position.y = -0.5;
scene.add(floor);

const wallGeoX = new THREE.BoxGeometry(1, 5, 20);
const wallGeoZ = new THREE.BoxGeometry(20, 5, 1);
const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

const wallBack = new THREE.Mesh(wallGeoZ, wallMat);
wallBack.position.set(0, 2, -10);
scene.add(wallBack);

const wallLeft = new THREE.Mesh(wallGeoX, wallMat);
wallLeft.position.set(-10, 2, 0);
const wallRight = new THREE.Mesh(wallGeoX, wallMat);
wallRight.position.set(10, 2, 0);
scene.add(wallLeft, wallRight);

const loader = new THREE.TextureLoader();
const idleTexture = loader.load('https://raw.githubusercontent.com/calvinchristensen96/Cribbage/refs/heads/main/assets/skunk-run/0.png');
const moveTexture = loader.load('https://raw.githubusercontent.com/calvinchristensen96/Cribbage/refs/heads/main/assets/skunk-run.png');

idleTexture.encoding = THREE.sRGBEncoding;
moveTexture.encoding = THREE.sRGBEncoding;

const playerMaterial = new THREE.SpriteMaterial({ map: idleTexture, transparent: true });
const player = new THREE.Sprite(playerMaterial);
player.scale.set(2, 2, 1);
player.position.set(0, 1, 0);
scene.add(player);

let frameIndex = 0;
let frameCounter = 0;
let currentTexture = idleTexture;

const idleFrames = 1;
const moveFrames = 17;
const frameRate = 0.8; 

function updateSpriteFrame(texture, frames, index) {
    const u = 1 / frames;
    texture.repeat.set(u, 1);
    texture.offset.set(u * index, 0);
}

const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

let yVelocity = 0;
let onGround = true;
const gravity = -0.01;
const jumpForce = 0.15;

function animate() {
    requestAnimationFrame(animate);

    const speed = 0.07;
    let moving = false;

    if (keys["ArrowLeft"]) {
        player.position.x -= speed;
        moving = true;
        player.scale.x = -Math.abs(player.scale.x);
    }
    if (keys["ArrowRight"]) {
        player.position.x += speed;
        moving = true;
        player.scale.x = Math.abs(player.scale.x);
    }
    if (keys["ArrowUp"]) { player.position.z -= speed * .6; moving = true; }
    if (keys["ArrowDown"]) { player.position.z += speed * .6; moving = true; }

    if (keys[" "] && onGround) {
        yVelocity = jumpForce;
        onGround = false;
    }

    yVelocity += gravity;
    player.position.y += yVelocity;

    if (player.position.y <= 0.62) {
        player.position.y = 0.62;
        yVelocity = 0;
        onGround = true;
    }

    player.position.x = Math.max(-9, Math.min(9, player.position.x));
    player.position.z = Math.max(-9, Math.min(10, player.position.z));

    if (moving) {
        currentTexture = moveTexture;
        playerMaterial.map = currentTexture;
        frameCounter += frameRate;
        if (frameCounter >= 1) {
            frameCounter = 0;
            frameIndex = (frameIndex + 1) % moveFrames;
        }
        updateSpriteFrame(currentTexture, moveFrames, frameIndex);
    } else {
        currentTexture = idleTexture;
        playerMaterial.map = currentTexture;
        frameCounter += frameRate;
        if (frameCounter >= 1) {
            frameCounter = 0;
            frameIndex = (frameIndex + 1) % idleFrames;
        }
        updateSpriteFrame(currentTexture, idleFrames, frameIndex);
    }

    playerMaterial.needsUpdate = true;

    const cameraOffset = new THREE.Vector3(0, 1, 4);
    camera.position.lerp(player.position.clone().add(cameraOffset), 0.1);

    renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
